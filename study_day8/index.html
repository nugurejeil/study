<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="author" content="Evan Han">
    <title>study_week8</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1 class="title">스 . 터 . 디 . W . E . E . K . 8</h1>
    <article>
        <h2 class="eraser">컨텐츠</h2> 
        <h2>자료형(Data Types)</h2>
        <section>
        <h2>원시자료형(primitive Types)</h2>
        <p>: 숫자, 문자열, Boolean, null, undefined</p>
        <ul>
            <li>
                <p>해당하는 리터럴(literal : 소스코드에서 고정된 값을 표현할 때 사용합니다. 해석하면 문자 그대로의, 직역의 ) 표현이 있습니다.</p>
            </li>
            <li>
                <p>자바스크립트는 모든 값을 객체처럼 다루므로 원시자료형에도 프로퍼티와 메소드가 존재하는 것처럼 보입니다. </p>
            </li>
            <li>
                <p>원시자료형이 저장된 변수를 다른 변수에 할당하면 값자체가 복사되고 복사된 변수를 변경해도 원래 변수는 변하지 않습니다.</p>
            </li>
            <li>
                <p> typeof 연산자를 사용해서 타입을 확인하기 쉽습니다.(숫자는 Number, 문자열은 String, Boolean은 true 혹은 false, 언디파인드는 undefined, null 의 경우 유일하게 타입이 object라고 표현되는데 이는 개발자의 실수입니다…)</p>
            </li>
        </ul>
        <h3>1. 숫자</h3>
        <ul>
            <li>
                <p>
                    정수, 실수등을 표현하는 원시타입. 리터럴로 표현하는 숫자는 10진수가 기본이나 8진수나 16진수 형태도 표현할 수 있습니다.(1234, 123.4, .5, '0x'로 시작하면 16진수, '0'으로 시작하면 8진수)
                </p>
            </li>
            <li>
                <p>
                    NaN(not a number) 도 숫자 자료형 중 하나입니다. NaN은 isNaN() 함수를 통해 확인합니다.
                </p>
            </li>
            <li>
                <p>
                    사칙연산, 나머지연산, 증감연산, 비트연산(10진수를 2진수로 변환해서 사용하는 연산자들 &amp;, |, ~, &raquo;, &laquo;, >>>), 단항연산자(부호를 바꿔줍니다. +, -)같은 연산자들을 사용합니다.
                </p>
            </li>
            <p>
                연산자들 사이에는 우선순위가 있습니다.
            </p>
            <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
            </a>
            <p>위 주소를 참고하시면 연산자들의 우선 순위를 알 수 있습니다.</p>
        </ul>
        <h3>2. 문자열</h3>
        <ul>
            <li>
                <p>
                    0개 이상 연속된 문자집합을 표현하는 원시타입입니다. 따옴표 또는 작은 따옴표로 묶은 연속된 문자입니다.(“문자열” 이나 혹은 ‘문자열’ 두 가지 다 가능한 표현입니다.)
                </p>
            </li>
            <li>
                <p>
                    [ ] 연산자로 특정 인덱스의 글자만 가져올 수 있습니다.
                </p>
                <pre>"Hello, world” [1] == ‘e’</pre>
            </li>
            <li>
                <p>
                    + 연산자로 문자열 두 개를 또는 문자열과 다른 자료형을 연결 할 수 있습니다.
                </p>
                <pre>“숫자” + 7 ==> "숫자7"</pre>
                <p>이렇듯, 다른 값을 문자열로 변환할 때는 String 생성자를 사용하거나 빈 문자열(“ ”)과 더하면 됩니다.(거의 대부분의 자료형이 문자열로 변화합니다.)</p>
            </li>
            <li>
                <p>문자열을 숫자로 바꿀때는 parseInt 또는 parseFloat 함수를 사용하거나 단항연산자(+, -)를 사용합니다.</p>
                <pre>parseInt(“30”) ==> 30</pre>
                <pre>parseInt(“30”, 16) --> 16진수 표현을 원할때 두번째 인수에 16을 넣어줍니다.</pre>
                <pre>parseFloat(“30.5”) ==> 30.5</pre>
                <pre>+”30” ==> 30</pre>
            </li>
            <li>
                <p>
                    활용도가 높은 메소드들
                </p>
                <code>
                    charAt(), charCodeAt(), replace(), indexOf(), lastIndexOf(), search(), slice(), split(), substr(), substring(), trim(), String.fromCharCode()
                </code>
            </li>
            <li>
                <p>
                    활용도가 높은 이스케이프 문자
                </p>
                <code>\r, \n, \t, \xNN, \uNNNN</code>
                <p>
                    문자열은 코드상에서 반드시 한줄에 끝나야 한다는 규칙이 있습니다. 때문에 줄바꿈이라든지, 유니코드 변환이라든지 문자열을 변화시키고 싶을때 이스케이프 문자를 사용합니다.
                </p>
            </li>
            <li>
                <p>ES2015에 와서  backtick 문자( ` ) 로 묶으면 템플릿 문자열이 됩니다. 또한 템플릿 문자열안에선 표현식도 사용할 수 있습니다.</p>
                <pre>
                    var name =“한재현”
                    `안녕하세요, ${name} 님` ==> “안녕하세요, 한재현님”  (== “안녕하세요 ”+ name + “님”)
                </pre>
                <pre>
                    var num = 10;
                    `${num *6}세에 저세상에서 날데리러 오거든 아직은 젊어서 못간다고 전해라` 
                    ==> 60세에 저 세상에서 날데리러 오거든 아직은 젊어서 못간다고 전해라
                </pre>
            </li>
        </ul>
        <h3>3. Boolean</h3>
        <ul>
            <li>
                <p>
                    true 혹은 false값을 가지는 자료형.
                </p>
            </li>
            <li>
                <p>
                    '!'는 '반대' 를 뜻합니다. true, false 에만 사용할 수 있습니다. 어떤 값의 true 혹은 false값을 알고 싶다면 앞에 !!를 붙입니다. (반대의 반대)
                </p>
            </li>
            <li>
                <p>
                    숫자중에서 false로 인정되는 것은 0, NaN. 나머지 숫자는 모두 ‘true’를 나타냅니다.
                </p>
            </li>
            <li>
                <p>
                    문자열 중에서는 오직 “ ”(빈 문자열) 만이 false 값을 나타냅니다.
                </p>
            </li>
        </ul>
        <h3>4. null</h3>
        <p>: 아무것도 없이 비어있는 값을 나타냅니다.</p>
        <h3>5. undefined</h3>
        <p>: 변수를 선언하고 아무런 값을 할당하지 않았을 때의 기본 값입니다. 예약어가 아니라서 다른 어떤 값을 할당 해도 문법에러가 발생하지 않습니다.</p>
        </section>
        
        <section>
        <h2>객체자료형(Object Types)으로 들어가기 전에...</h2>
        <p>자바스크립트의 모든 값은 <span>객체</span>처럼 다루어집니다. 이 말은 곧 각 타입마다 고유한 속성(<span>프로퍼티</span>)과 실행동작(<span>메소드</span>)이 있다는 뜻입니다.</p>
        <p>예를 들어, 문자열에도 사실 <span>.length</span> 라는 프로퍼티와 <span>.indexOf()</span> 라는 메소드가 존재합니다.</p>
        <pre>
            var 문자열 = “tis 스터디”
            문자열.length;        ==> 7
            문자열.indexOf(‘터’);  ==> 5
        </pre>
        <h3>생성자</h3>
        <ul class="constructor">
            <li>
                <p>각 타입에는 타입의 성격을 정하는 <span>생성자</span>(constructor) 가 있습니다. 생성자를 통해 우리는 <span>인스턴스</span>(instance)를 만들어 사용합니다.</p>
                <figure>
                    <img src="img/frame.jpeg" alt="붕어빵틀" title="하나 있었으면....">
                    <figcaption>생성자가 붕어빵틀 이라면!</figcaption>
                </figure>
                <figure>
                    <img src="img/fishbread.png" alt="붕어빵" title="아름답다.">
                    <figcaption>인스턴스는 생성자로 만든 붕어빵입니다!</figcaption>
                </figure>
            </li>
            <li>
                <p>생성자의 이름은 대문자로 시작합니다.(Number, String 등등)</p>
            </li>
            <li>
                <p>각 프로퍼티와 메소드에는 고유한 이름과 값이 있습니다. </p>
            </li>
        </ul>
        <h2>객체자료형(Object Types)</h2>
        <ul>
            <li>
                <p>
                    ‘참조자료형’(Reference Type)이라고도 부릅니다.
                </p>
            </li>
            <li>
                <p>
                    객체자료형의 값은 객체의 인스턴스입니다.
                </p>
            </li>
            <li>
                <p>
                    new 연산자를 사용해 인스턴스를 만듭니다. ( var name = new Object(); )
                </p>
            </li>
            <li>
                <p>
                    typeof 연산자를 사용하면 대부분 “object” 가 반환됩니다. (함수, 정규표현식 제외)
                </p>
            </li>
            <li>
                <p>
                    생성자로 객체를 생성하여 값을 할당하고 그 값을 복제하면 ‘값 자체’를 복제하는 것이 아니라 그 값이 위치한 ‘주소’를 복사합니다. 그래서 ‘참조’ 자료형이라고도 부르는 것 입니다. 값 자체를 복제해버리는 원시자료형과는 다릅니다.
                </p>
                <pre>
                    var obj1 = new Object( );
                    var obj2 = obj1;
                    obj2.name = '재현';
                    obj1.name = '재현';
                    
                    * obj1과 obj2는 메모리상의 <span>같은 주소</span>를 참조하고 있습니다. 때문에 obj2의 값이 바뀌면 obj1의 값도 바뀝니다.
                </pre>
            </li>
            <li>
                <p>
                    instanceof 연산자를 통해 생성자 - 인스턴스의 관계를 알 수 있습니다.
                </p>
                <pre>
                    var arr = new Array;
                    arr instanceof Array; ==>  true
                </pre>
            </li>
        </ul>
        <h3>1. 배열(Array)</h3>
        <ul>
            <li>
                <p>
                    데이터의 집합. 여러 값을 하나의 이름으로 묶어두고 사용할 수 있습니다.
                </p>
                <pre>
                    var 장볼거1 = “소고기”;
                    var 장볼거2 = “상추”;
                    var 장볼거3 = “쌈장”;
                    var 장볼거4 = “마늘”;
                    
                    ==> var 심부름 = new Array(‘소고기’, ‘상추’, ‘쌈장’, ‘마늘’);
                </pre>
            </li>
            <li>
                <p>
                    배열의 각 값을 원소(element)라고 부릅니다.
                </p>
            </li>
            <li>
                <p>
                    배열의 크기는 .length 프로퍼티를 통해 알 수 있습니다. 또한 임의의 값을 넣어 배열의 크기를 조절할 수도 있습니다.
                </p>
                <pre>
                    var 배열 = new Array(); --> '배열'이란 이름의 배열을 생성합니다.
                    배열.length = 10;       --> 배열의 길이를 10으로 만들었습니다.
                    console.log(배열)       ==> [undefined × 10] --> 언디파인드 10개로 이루어진 배열로 변했습니다.
                </pre>
            </li>
            <li>
                <p>
                    생성자에 숫자 한개만 넣으면 배열의 크기가 되고 여러개를 넣으면 배열의 원소가 됩니다.
                </p>
                <pre>
                    var a = new Array();           --> a.length == 0
	                var a = new Array(10);         --> a.length == 10
	                var a = new Array(10, 20, 30); --> a.length == 3
                </pre>
            </li>
            <li>
                <p>
                    배열도 리터럴 표현이 있습니다.
                </p>
                <pre>
                    new Array() 대신 [ ]기호를 사용해서 생성합니다.
                    
	                var arr = [ ];           --> 원소가 없는 배열
	                var arr =[ 10, 20, 30 ]  --> 원소가 3개인 배열
                </pre>
            </li>
            <li>
                <p>
                    각괄호 + 인덱스를 통해 각 값에 접근할 수 있습니다. 특정 원소에 값을 저장할 수도 있습니다. 심지어 원래는 없는 자리에 원소값을 넣어 줄 수도 있습니다.
                </p>
                <pre>
                    var arr = [10, 20, 30];
                    arr[0] == 10;          -->배열 arr의 첫번째 값에 접근합니다.
                    arr[10]  == undefined; -->배열을 생성할 때는 없었던 10번째 배열 원소를 만들어줬습니다.
                    arr[10] = 40;          -->배열을 생성할 때는 없었던 10번째 배열 원소를 만들어주고 그 자리에 40을 넣어줬습니다.
                </pre>
            </li>
            <li>
                <p>
                    리터럴 생성과 동시에 원소에 접근 할 수도 있습니다.
                </p>
                <pre>
                    var a = [10, 20, 30][1]; 
                    console.log(a) ==> 20;
                </pre>
            </li>
            <li>
                <p>많이 사용하는 배열 메소드</p>
                <code>concat(), filter(), forEach(), indexOf(), join(), map(), pop(), push(), reverse(), shift(), slice(), sort(), unshift()</code>
            </li>
        </ul>
        <h3>2. 객체(Object)</h3>
        <ul>
            <li>
                <p>
                    키와 값으로 이루어진 데이터의 집합. 배열과 다른건 각 값에는 고유한 <span>이름(key값)</span>이 있다는 것 입니다.
                </p>
                <pre>
                    var 나 = new Object(); --> '나' 라는 이름의 <span>객체</span>를 생성했습니다.
                    
                    나.이름 = “한재현”;       
                    --> 점(.) 문법을 통해 객체에 '이름' 이란 이름(키값)의 <span>프로퍼티</span>를 생성하고 여기에 '한재현'이란 데이터 값을 넣었습니다.
                    
                    나.성별 = “남자”;        
                    --> 점(.) 문법을 통해 객체에 '성별' 이란 이름(키값)의 <span>프로퍼티</span>를 생성하고 여기에 '남자'란 데이터 값을 넣었습니다.
                </pre>
            </li>
            <li>
                <p>
                    리터럴 표현을 사용하면 객체와 프로퍼티를 동시에 만들 수 있습니다.
                </p>
                <pre>
                    var obj ={
                        newProperty: “value”,
                        “property” : 123
                    };  --> 중괄호({ })를 통해 객체를 생성합니다. 또한 키와 값 사이에는 콜론(:)을 두어 구분하고, 각 프로퍼티는 쉼표로 구분합니다.
                    
                    * 프로터티의 이름은 원래 <span>문자열</span>로 만드는게 정석이지만 변수이름 명명 규칙을 따른다면 문자열이 아니더라도 상관없습니다.
                </pre>
            </li>
            <li>
                <p>
                    각괄호 문법을 통해서도 프로퍼티에 접근할 수 있습니다.
                </p>
                <pre>
                    obj[“newProperty”] = “value”;                
                </pre>
            </li>
            <li>
                <p>
                    delete 연산자를 사용해 프로퍼티를 제거할 수 있습니다.
                </p>
                <pre>
                    delete obj.newProperty1; --> obj 객체안에 있는 newProperty1 프로터피를 삭제합니다.
                </pre>
            </li>
            <li>
                <p>
                    in 연산자를 사용하면 특정 프로퍼티 이름이 객체에 존재하는지 알 수 있습니다.
                </p>
                <pre>
                    “propertyName” in obj —> true, false 값을 반환합니다.
                </pre>
            </li>
            <li>
                <p>
                    활용도가 높은 메소드
                </p>
                <code>
                    Object.assign(), Object.create(), Object.defineProperty(), Object.definePropertires(), Object.keys(), hasOwnProperty()
                </code>
            </li>
            <li>
                <p>
                    사실, 자바스크립트의 모든 객체는 고유의 타입을 가지기도 하지만 Object 타입이기도 합니다.
                </p>
                <pre>
                    [ ] instanceof Array == true  --> []는 배열의 인스턴스인가? true
                    [ ] instanceof Object == true --> []는 오브젝트의 인스턴스인가? true
                </pre>
                <pre>
                    var arr = [1,2,3];
                    arr.안녕 = “하세요”;
                    --> arr은 배열이지만 동시에 '안녕' 이라는 프로퍼티도 가집니다.
                </pre>
            </li>
        </ul>
        </section>
    </article>
   
</body>
</html>







